#include"math.h"
#include"stdio.h"
#include"stdlib.h"

void DFT(float *x, float *xr, float *xi, int N, float s);
void Spectrum(float *Xr, float *Xi, float *Amp, float *phi, int N);
extern void signal(float *h, float f, float dt, float m, int N);
extern void output_h(float *x, float T, int N);
extern void output_S_3(float *Xamp, float *phi, float T, int N);
extern void FFT(float *x, float *xr, float *xi, int N);
# define PI 3.14159


//------------------------------------------------------------//
//         实验-3：  计算离散信号的振幅谱和相位谱             //
//                                                            //
//   1.  编程任务:  1. 编写计算DFT正、反变换的程序。          //
//                                                            //
//                  2. 编写计算振幅谱和相位谱的程序。         // 
//                                                            //
//   2.  用Excel软件绘图显示计算结果。                        //
//                                                            // 
//   3.  比较DFT和FFT的计算速度。                             //
//                                                            //
//------------------------------------------------------------//
//                                                            //
//   编写程序的位置:                                          //
//                                                            //
//   1.  在函数DFT()中完成计算DFT正、反变换的编程             //
//                                                            //
//   2.  在函数Spectrum()中完成计算                           //
//  	 振幅谱 Amp[i] 和 相位谱 phi[i]的编程                 // 
//                                                            //
//                                                            //
//------------------------------------------------------------//

void main()
{
    float x[256], x1[256], Xr[256]={0}, Xi[256]={0}, Amp[256], phi[256],
		  deltat, M, f;
	int   N;

//---------------------------------------------------------//
//             生成离散信号x[n]，用于DFT计算               //
//---------------------------------------------------------//

    deltat=float(0.002);  // 时域采样间隔(sec)
    N=256;                // 数据长度(点数)
	f=20;                 // 信号的频率
	M=float(1.1);
    signal(x, f, deltat, M, N);

//---------------------------------------------------------//
//       调用函数DFT()计算信号x[n]的离散傅里叶变换         //
//---------------------------------------------------------//

    DFT(x, Xr, Xi, N, 1);

	
//---------------------------------------------------------//
//       调用函数Spectrum()振幅谱和相位谱                  //
//---------------------------------------------------------//

    Spectrum(Xr, Xi, Amp, phi, N);
  
//--------------------------------------------------//
//         输出振幅谱和相位谱计算结果               //
//--------------------------------------------------//

    output_S_3(Amp, phi, deltat, N);

//------------------------------------------//
//           检验离散傅立叶反变换           //
//------------------------------------------//

//    DFT(x1, Xr, Xi, N, -1);
    output_h(x1, deltat, N);


//##########################################//
//------------------------------------------//
//   试验任务:  比较DFT和FFT的计算速度      //
//------------------------------------------//
//##########################################//
//	printf("  Test for FFT !!\n\n");
//    for(k=0; k<2000; k++)
//    {    DFT(x, Xr, Xi, N, 1);  }
//    {    FFT(x, Xr, Xi, N);     }


//-----------------------------------------------//
        printf("\n   运算结束 !! \n\n");
//-----------------------------------------------//
}




//#########################################################//
//                                                         //
//       编程 :   计算离散傅里叶变换DFT                    //
//                                                         //
//  -------------------------------------------------------//
//          在该函数段中编写计算DFT的程序 !!!              //
//                                                         //
//     x[]:  时域离散信号；                                //
//    Xr[]:  DFT的的实部；                                 //
//    Xi[]:  DFT的的虚部；                                 //
//       N:  数据长度；                                    //
//       s:  是正反变换控制变量；s=1:正变换；s=-1:反变换   //
//                                                         //
//  -------------------------------------------------------//
//#########################################################//
void DFT(float *x, float *Xr, float *Xi, int N, float s)   
{
	float sum(int k, float *x, int N);
	float sum1(int k, float *x, int N);
	int k; 
	float sum;
	if(s==1) {
		for(k=0; k<N; k++) {
			Xr[k] = sum(k,x,N);
			Xi[k] = sum1(k,x,N);
		}
	}
	else {
		for(int n=0; n<N; n++)
		{
			x[j] += Xr[n] * cos( (2*PI)/N * j * n ) + Xi[n] * sin((2*PI)/N * j * n); 
		}		
	}
}
float sum(int k, float *x, int N, float s)
{
	int j;
	float sum = 0;
	for(j=0; j<N; j++)
	{
		sum = sum + x[j] * cos( (2*PI)/N * j * k );
	}	
	return sum;
}
float sum1(int k, float *x, int N, float s)
{
	float sum = 0;
	int j;
	for(j=0; j<N; j++)
	{
		sum = sum + (x[j] * sin((2*PI)/N * j * k));
	}
	return -sum;
}

//####################################################//
//                                                    //
//       编程 :   计算振幅谱和相位谱                  //
//                                                    //
//  --------------------------------------------------//
//                                                    //
// 在此处编写计算振幅谱 Amp[i] 和 相位谱 phi[i]的程序 //
//                                                    //
//     Xr[]:  DFT的的实部；                           //
//     Xi[]:  DFT的的虚部；                           //
//    Amp[]:  需要计算的振幅谱；                      //
//    phi[]:  需要计算的相位谱；                      //
//        N:  数据长度；                              //
//                                                    //
//####################################################//
void Spectrum(float *Xr, float *Xi, float *Amp, float *phi, int N)   
{
	int i;

	for(i=0; i<N; i++) {
		Amp[i] = sqrt(pow(Xr[i],2) + pow(Xi[i],2));	
		phi[i] =  atan(Xi[i] / Xr[i]);
	}
}